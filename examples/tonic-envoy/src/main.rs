use bytes::Bytes;
use futures::StreamExt;
use proto::{
    key_value_store_client::KeyValueStoreClient, key_value_store_server, GetReply, GetRequest,
    SetReply, SetRequest, SubscribeReply, SubscribeRequest,
};
use std::{
    collections::HashMap,
    net::SocketAddr,
    net::TcpListener,
    pin::Pin,
    sync::{Arc, RwLock},
    time::Duration,
};
use structopt::StructOpt;
use tokio::io::AsyncReadExt;
use tokio::sync::broadcast::{channel, Sender};
use tokio_stream::{wrappers::BroadcastStream, Stream};
use tonic::{async_trait, body::BoxBody, transport::Channel, Code, Request, Response, Status};

mod proto {
    tonic::include_proto!("key_value_store");
}

/// Simple key/value store with an HTTP API
#[derive(Debug, StructOpt)]
struct Config {
    /// The port to listen on
    #[structopt(long, short = "p", default_value = "3000")]
    port: u16,

    #[structopt(subcommand)]
    command: Command,
}

#[derive(Debug, StructOpt)]
enum Command {
    /// Run the gRPC server
    Server,
    /// Get the value at some key
    Get {
        #[structopt(long, short = "k")]
        key: String,
    },
    /// Set a value at some key.
    ///
    /// The value will be read from stdin.
    Set {
        #[structopt(long, short = "k")]
        key: String,
    },
    /// Subscribe to a stream of inserted keys
    Subscribe,
}

#[tokio::main]
async fn main() {

    // Parse command line arguments
    let config = Config::from_args();

    // The server address
    let addr = SocketAddr::from(([0, 0, 0, 0], config.port));

    match config.command {
        Command::Server => {
            let db = Arc::new(RwLock::new(HashMap::new()));
        
            let (tx, _rx) = channel(1024);
            let addr = "0.0.0.0:50051".parse().unwrap();
        
            // Build our tonic `Service`
            let service = key_value_store_server::KeyValueStoreServer::new(ServerImpl { db, tx });
        
        
            tonic::transport::Server::builder()
                .add_service(service)
                .serve(addr)
                .await.unwrap();
        }
        Command::Get { key } => {
            // Create a client for our server
            let mut client = KeyValueStoreClient::connect(String::from("http://localhost:50051")).await.unwrap();

            // Issue a `GetRequest`
            let result = client.get(GetRequest { key }).await;

            match result {
                // If it succeeds print the value
                Ok(response) => {
                    let value_bytes = response.into_inner().value;
                    let value = String::from_utf8_lossy(&value_bytes[..]);
                    print!("{}", value);
                }
                // If not found we shouldn't panic
                Err(status) if status.code() == Code::NotFound => {
                    eprintln!("not found");
                    std::process::exit(1);
                }
                // Panic on other errors
                Err(status) => {
                    panic!("{:?}", status);
                }
            }
        }
        Command::Set { key } => {
            // Create a client for our server
            let mut client = KeyValueStoreClient::connect(String::from("http://localhost:50051")).await.unwrap();

            // Read the value from stdin
            let mut stdin = tokio::io::stdin();
            let mut value = Vec::new();
            stdin.read_to_end(&mut value).await.unwrap();

            // Issue a `SetRequest`
            client.set(SetRequest { key, value }).await.unwrap();

            // All good :+1:
            println!("OK");
        }
        Command::Subscribe => {
            // Create a client for our server
            let mut client = KeyValueStoreClient::connect(String::from("http://localhost:50051")).await.unwrap();

            // Create a subscription
            let mut stream = client
                .subscribe(SubscribeRequest {})
                .await
                .unwrap()
                .into_inner();

            println!("Stream created!");

            // Await new items
            while let Some(item) = stream.next().await {
                let item = item.unwrap();
                println!("key inserted: {:?}", item.key);
            }
        }
    }
}

// Implementation of the server trait generated by tonic
#[derive(Debug, Clone)]
struct ServerImpl {
    db: Arc<RwLock<HashMap<String, Bytes>>>,
    tx: Sender<SubscribeReply>,
}

#[async_trait]
impl key_value_store_server::KeyValueStore for ServerImpl {
    async fn get(&self, request: Request<GetRequest>) -> Result<Response<GetReply>, Status> {
        let key = request.into_inner().key;

        if let Some(value) = self.db.read().unwrap().get(&key).cloned() {
            let reply = GetReply {
                value: value.to_vec(),
            };

            Ok(Response::new(reply))
        } else {
            Err(Status::not_found("key not found"))
        }
    }

    async fn set(&self, request: Request<SetRequest>) -> Result<Response<SetReply>, Status> {
        let SetRequest { key, value } = request.into_inner();
        let value = Bytes::from(value);

        self.tx
            .send(SubscribeReply { key: key.clone() })
            .expect("failed to send");

        self.db.write().unwrap().insert(key, value);

        Ok(Response::new(SetReply {}))
    }

    type SubscribeStream =
        Pin<Box<dyn Stream<Item = Result<SubscribeReply, Status>> + Send + Sync + 'static>>;

    async fn subscribe(
        &self,
        request: Request<SubscribeRequest>,
    ) -> Result<Response<Self::SubscribeStream>, Status> {
        let SubscribeRequest {} = request.into_inner();

        let rx = self.tx.subscribe();
        let stream = BroadcastStream::new(rx)
            .filter_map(|item| async move {
                // ignore receive errors
                item.ok()
            })
            .map(Ok);
        let stream: Self::SubscribeStream = Box::pin(stream);
        let res = Response::new(stream);

        Ok(res)
    }
}